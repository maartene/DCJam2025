# TECHDEBT

## ⚠️ TODO
- the UI will require more helper functions to draw the right buttons
- Determining if party is in line of sight of enemy uses a naive raycast approach. this could be easier more elegant.
- Rotating towards party is based on trial and error: rotate, see if facing party. otherwise repeat. this could be based on dot product
- Duplication of logic between Enemy and World (Party)
    - Is it possible to re-use attack strategy?
- Similarity between health of enemy and party members

## 🚧 DOING
- remove the @testable from the import statement in the tests
    - [X] Remove from `EnemyTests.swift`
        - [X] make `makeWorld` public
            - [X] make `World` public
        - [X] make `update` public
        - [X] make World initializer public
            - [X] make CompassDirection public
            - [X] make Coordinate initializer public
                - [ ] make toVector3 public
            - [X] make Floor public
    - [X] ImportWorldTests
    - [X] LostConditionTests
    - [X] MappingTests
        - [X] make visitedTilesOnCurrentFloor public
    - [X] MovementTests
    - [ ] PartyAttackTests
            


## ✅ DONE
- no test coverage for conversion of coordinate spaces, while this might be valuable. Maybe property based testing?
- a lot of the minimap code could be tested, in particular the conversion of units and determining of correct tile names
- missing test for color multiplication in Conversions.swift
- should not be able to rotate when goal is reached
- minX, minY, maxX and maxY are constants, so can be generated only once
- missing tests in Floor
- `enemies` in `World` should not just be a coordinate, and also wrapped in its own data type
    - [X] Enemy needs to conform to `Hashable`
        - [X] Update needs to work on enemy positions
        - [X] `spawnEnemy` should create a new Enemy
- Extract conditional in update
- message chain in `LostConditionTests` because `World` exposes array with partymembers
- enemies should be part of floor definition -> requires update to `makeWorld(from:)`
- enemies are bound to floor
- principal obsession in `partyMemberIndex`
- array with partymembers should be wrapped in its own data type
- there is duplication in `World` where multiple functions do the same check: see if player already won. Abstraction needed to conform to DRY
- Convenience initiazer is not needed and is a risk if it is not updated in sync with the regular initiazer.
- Feature envy in World.update on Enemy
- Magic numbers for range in Enemy.swift
    - [X] Range
    - [X] Damage
- DRY in MeleeEnemy and RangedEnemy
- [X] Strategy pattern for Enemies
    - [X] Make `Enemy` a final class
        - [X] Remove `MeleeEnemy` class
            - [X] `makeMeleeEnemy` should create an `Enemy` instance
                - [X] Inject `MeleeAttackStrategy` into `Enemy`
                    - [X] Create `MeleeAttackStrategy`
                    - [X] Remove `range` from `Enemy`
                        - [X] move `range` into `MeleeAttackStrategy`
                        - [X] move `partyIsInRange` to `MeleeAttackStrategy`
            - [X] use `makeMeleeEnemy` in tests
        - [X] Remove `RangedEnemy` class
            - [X] `makeRangedEnemy` should create an `Enemy` instance
                - [X] Inject `RangedAttackStrategy` into `Enemy`
                    - [X] Create `RangedAttackStrategy`
                    - [X] An `Enemy` needs to accept all types of AttackStrategies
                        - [X] Introduce `AttackStrategy` protocol
                        - [X] `AttackStrategy` protocol requires range
                        - [X] `AttackStrategy` protocol requires getValidTargets
                - [X] Remove override attack methods
                    - [X] `MeleeEnemy`
                        - [X] `AttackStrategy` needs access to damage
                    - [X] `RangedEnemy`
    - [X] remove `range` from `Enemy`
        - [X] partyIsInRange should not use range
    - [X] remove `damage` from `Enemy`
- [X] DRY: move as much from strategies into default implementations as possible
- Movement tests in `EnemyMovementTests` use hard coded paths, these should be generated using a path finding algorithm like Dijkstra or BFS
- Is a KeyPath the right way of describing the position of a party member?
    - [X] remove frontLeft/right
        - [X] frontRow uses getMember 
            - [X] add a getMember function
        - [X] drawParty uses getMember
        - [X] test notLostWhenAtLeastOnePartyMemberIsAlive needs to use getMember
        - [X]  meleeAttackFromBackRowDoesNotDamageEnemy needs to not use the keypath solution
            - [X] attack needs to take an SinglePartyPosition as associate value
                - [X] add a new attackNew value and use a SinglePartyPosition
                - [X] Tests use the new enum case
    - [X] Remove backLeft/right
    - [X] Remove frontRow
        - [X] MeleeAttackStrategy needs to use getMembers
            - [X] Introduce getMembers function
    - [X] Remove backrow
    - [X] Remove all
